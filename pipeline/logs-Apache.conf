# =============================================================================
# LOGSTASH PIPELINE CONFIGURATION
# =============================================================================
# Fichier: logstash.conf
# Dataset utilisé: Apache Access Logs (format Common Log Format)
# URL du dataset: https://www.sec.cs.ucl.ac.uk/users/smurdoch/papers/oakland10ccscanner.html

input {
  file {
    path => "/usr/share/logstash/config/data/logs/apache.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "plain"
    tags => ["apache", "web_access"]
    type => "apache"              # Type de log
    mode => "read" 
  }
}


filter {
  dissect {
    mapping => {
      "message" => '%{clientip} - - [%{timestamp}] "%{verb} %{request} HTTP/%{httpversion}" %{response} %{bytes} "%{referrer}" "%{user_agent}"'
    }
    tag_on_failure => ["_dissectfailure", "_apache_parse_failure"]
  }

  if "_apache_parse_failure" in [tags] {
    drop {}
  }

  date {
    match => ["timestamp", "dd/MMM/yyyy:HH:mm:ss Z"]
    timezone => "Europe/Paris"
    target => "@timestamp"
  }

  grok {
    match => {
      "request" => [
        "%{URIPATH:url.path}(?:%{URIPARAM:url.query})?",
        "/"
      ]
    }
    tag_on_failure => []
    overwrite => ["url"]
  }

  translate {
    source => "response"
    target => "http.response.status_code"
    dictionary => {
      "200" => "OK"
      "403" => "Forbidden"
      "404" => "Not Found"
      "405" => "Method Not Allowed"
      "416" => "Range Not Satisfiable"
      "500" => "Internal Server Error"
      "503" => "Service Unavailable"
      "413" => "Payload Too Large"
      "410" => "Gone"
    }
    fallback => "Unknown HTTP Status"
  }

  geoip {
    source => "clientip"
    target => "source"
  }

  useragent {
    source => "user_agent"
    target => "user_agent"
    lru_cache_size => 1000
  }

  # --- CORRECTION APPLIQUEE ICI ---
  mutate {
    convert => {
      "response" => "integer"
      "bytes" => "integer" # <-- CORRECTION: 'long' remplacé par 'integer'
    }
    rename => {
      "clientip" => "source.ip"
      "verb" => "http.request.method"
      "bytes" => "http.response.bytes"
      "referrer" => "http.request.referrer"
    }
    remove_field => [
      "timestamp",
      "message",
      "httpversion"
    ]
    gsub => [
      "http.request.referrer", "-", ""
    ]
  }
  # --- FIN DE LA CORRECTION ---

  if [user_agent.original] =~ /sqlmap|nmap|wget|curl/ {
    mutate {
      add_tag => ["security_scan"]
      add_field => { "event.category" => "intrusion_detection" }
    }
  }
  if [url.path] =~ /(\.sql|\.php|\.env|backup|admin|internal)/ {
    mutate {
      add_tag => ["sensitive_access_attempt"]
    }
  }

  if [user_agent.name] == "Googlebot" or [user_agent.name] == "Bingbot" {
    mutate {
      add_tag => ["search_engine_bot"]
    }
  }

  mutate {
    add_field => {
      "event.kind" => "event"
      "event.type" => "access"
      "event.dataset" => "apache.access"
    }
  }
}

output {
  # =============================================================================
  # OUTPUT VERS ELASTICSEARCH AVEC PERSISTENT QUEUE
  # =============================================================================
  elasticsearch {
    hosts => ["https://elasticsearch:9200"]
    # Configuration SSL simplifiée - seulement vérification du serveur
    ssl_enabled => true
    ssl_certificate_authorities => "/usr/share/logstash/config/certs/ca/ca.crt"
    ssl_verification_mode => "full"
    user => "elastic"
    password => "${ELASTIC_PASSWORD}"
 
    index => "apache-logs-%{+yyyy.MM.dd}"
    template_name => "apache-logs-template"
    #template_pattern => "apache-logs-*"
    #template_overwrite => true
    
    # Configuration Persistent Queue
    pipeline => "apache-logs-pipeline"
    
    # Gestion des erreurs
    manage_template => true
  }
  # =============================================================================
  # OUTPUT DEBUG (optionnel)
  # =============================================================================
  # stdout {
  #   codec => rubydebug {
  #     metadata => false
  #   }
  # }

 # Sortie de debug pour vérifier le résultat du parsing
  if "_debug" in [tags] {
    stdout {
      codec => rubydebug
    }
  }

}

